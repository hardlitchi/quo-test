# DTO/Bean設計書

## 概要
quo-testプロジェクトにおけるDTO（Data Transfer Object）とBean設計を定義する。
Web層（Controller）とService層間のデータ交換、およびクライアントとの通信に使用する。

## 設計方針

### 基本方針
- **レイヤー間の責務分離**: Entity ↔ Service ↔ Web層で適切なデータ変換
- **バリデーション**: リクエストDTOにバリデーションアノテーションを設定
- **null安全性**: Kotlinのnull安全機能を活用
- **不変性**: data classを使用してイミュータブルなオブジェクトを作成

### パッケージ構成
```
test.quo.hardlitchi.web.bean
├── request/     # リクエストDTO
├── response/    # レスポンスDTO
└── common/      # 共通Bean
```

## 共通Bean

### API共通レスポンス
```kotlin
/**
 * API成功レスポンス
 */
data class ApiResponse<T>(
    val success: Boolean = true,
    val data: T,
    val message: String? = null,
    val timestamp: String = LocalDateTime.now().toString()
)

/**
 * APIエラーレスポンス
 */
data class ApiErrorResponse(
    val success: Boolean = false,
    val data: Any? = null,
    val message: String,
    val errors: List<FieldErrorDto> = emptyList(),
    val timestamp: String = LocalDateTime.now().toString(),
    val path: String? = null
)

/**
 * フィールドエラー詳細
 */
data class FieldErrorDto(
    val field: String,
    val message: String,
    val rejectedValue: Any? = null
)
```

## 著者関連DTO

### リクエストDTO
```kotlin
/**
 * 著者登録リクエスト
 */
data class CreateAuthorRequest(
    @field:NotBlank(message = "著者名は必須です")
    @field:Size(max = 100, message = "著者名は100文字以内で入力してください")
    val name: String,

    @field:NotNull(message = "生年月日は必須です")
    @field:Past(message = "生年月日は過去の日付である必要があります")
    val birthDate: LocalDate
)

/**
 * 著者更新リクエスト
 */
data class UpdateAuthorRequest(
    @field:NotNull(message = "生年月日は必須です")
    @field:Past(message = "生年月日は過去の日付である必要があります")
    val birthDate: LocalDate
)
```

### レスポンスDTO
```kotlin
/**
 * 著者レスポンス
 */
data class AuthorResponse(
    val name: String,
    val birthDate: LocalDate,
    val createdAt: LocalDateTime,
    val updatedAt: LocalDateTime
) {
    companion object {
        /**
         * EntityからDTOに変換
         */
        fun from(author: Author): AuthorResponse {
            return AuthorResponse(
                name = author.name,
                birthDate = author.birthDate,
                createdAt = author.createdAt,
                updatedAt = author.updatedAt
            )
        }
    }
}

/**
 * 著者一覧レスポンス
 */
data class AuthorListResponse(
    val authors: List<AuthorResponse>
) {
    companion object {
        fun from(authors: List<Author>): AuthorListResponse {
            return AuthorListResponse(
                authors = authors.map { AuthorResponse.from(it) }
            )
        }
    }
}
```

## 書籍関連DTO

### リクエストDTO
```kotlin
/**
 * 書籍登録リクエスト
 */
data class CreateBookRequest(
    @field:NotBlank(message = "書籍タイトルは必須です")
    @field:Size(max = 200, message = "書籍タイトルは200文字以内で入力してください")
    val title: String,

    @field:NotNull(message = "価格は必須です")
    @field:DecimalMin(value = "0", message = "価格は0以上である必要があります")
    val price: BigDecimal,

    @field:NotNull(message = "出版状況は必須です")
    val publicationStatus: PublicationStatus,

    @field:NotEmpty(message = "著者は最低1人必要です")
    @field:Size(min = 1, message = "著者は最低1人必要です")
    val authors: List<
        @NotBlank(message = "著者名は必須です")
        @Size(max = 100, message = "著者名は100文字以内で入力してください")
        String
    >
) {
    /**
     * リクエストの整合性をチェック
     */
    @AssertTrue(message = "著者リストが空です")
    fun isAuthorsValid(): Boolean {
        return authors.isNotEmpty() && authors.all { it.isNotBlank() }
    }
}

/**
 * 書籍更新リクエスト
 */
data class UpdateBookRequest(
    @field:NotNull(message = "価格は必須です")
    @field:DecimalMin(value = "0", message = "価格は0以上である必要があります")
    val price: BigDecimal,

    @field:NotNull(message = "出版状況は必須です")
    val publicationStatus: PublicationStatus,

    @field:NotEmpty(message = "著者は最低1人必要です")
    @field:Size(min = 1, message = "著者は最低1人必要です")
    val authors: List<
        @NotBlank(message = "著者名は必須です")
        @Size(max = 100, message = "著者名は100文字以内で入力してください")
        String
    >
) {
    @AssertTrue(message = "著者リストが空です")
    fun isAuthorsValid(): Boolean {
        return authors.isNotEmpty() && authors.all { it.isNotBlank() }
    }
}
```

### レスポンスDTO
```kotlin
/**
 * 書籍レスポンス
 */
data class BookResponse(
    val title: String,
    val price: BigDecimal,
    val publicationStatus: PublicationStatus,
    val authors: List<String>,
    val createdAt: LocalDateTime,
    val updatedAt: LocalDateTime
) {
    companion object {
        /**
         * EntityとPublicationリストからDTOに変換
         */
        fun from(book: Book, authors: List<String>): BookResponse {
            return BookResponse(
                title = book.title,
                price = book.price,
                publicationStatus = book.publicationStatus,
                authors = authors,
                createdAt = book.createdAt,
                updatedAt = book.updatedAt
            )
        }
    }
}

/**
 * 書籍一覧レスポンス
 */
data class BookListResponse(
    val books: List<BookResponse>
) {
    companion object {
        fun from(booksWithAuthors: List<Pair<Book, List<String>>>): BookListResponse {
            return BookListResponse(
                books = booksWithAuthors.map { (book, authors) ->
                    BookResponse.from(book, authors)
                }
            )
        }
    }
}
```

## Service層DTO

### 内部データ転送用DTO
```kotlin
/**
 * 著者作成用DTO
 */
data class CreateAuthorDto(
    val name: String,
    val birthDate: LocalDate,
    val createdBy: String = "system"
) {
    companion object {
        fun from(request: CreateAuthorRequest): CreateAuthorDto {
            return CreateAuthorDto(
                name = request.name,
                birthDate = request.birthDate
            )
        }
    }
    
    /**
     * DTOからEntityに変換
     */
    fun toEntity(): Author {
        val now = LocalDateTime.now()
        return Author(
            name = name,
            birthDate = birthDate,
            createdAt = now,
            createdBy = createdBy,
            updatedAt = now,
            updatedBy = createdBy
        )
    }
}

/**
 * 著者更新用DTO
 */
data class UpdateAuthorDto(
    val name: String,
    val birthDate: LocalDate,
    val updatedBy: String = "system"
) {
    companion object {
        fun from(name: String, request: UpdateAuthorRequest): UpdateAuthorDto {
            return UpdateAuthorDto(
                name = name,
                birthDate = request.birthDate
            )
        }
    }
}

/**
 * 書籍作成用DTO
 */
data class CreateBookDto(
    val title: String,
    val price: BigDecimal,
    val publicationStatus: PublicationStatus,
    val authors: List<String>,
    val createdBy: String = "system"
) {
    companion object {
        fun from(request: CreateBookRequest): CreateBookDto {
            return CreateBookDto(
                title = request.title,
                price = request.price,
                publicationStatus = request.publicationStatus,
                authors = request.authors
            )
        }
    }
    
    /**
     * DTOからEntityに変換
     */
    fun toBookEntity(): Book {
        val now = LocalDateTime.now()
        return Book(
            title = title,
            price = price,
            publicationStatus = publicationStatus,
            createdAt = now,
            createdBy = createdBy,
            updatedAt = now,
            updatedBy = createdBy
        )
    }
}

/**
 * 書籍更新用DTO
 */
data class UpdateBookDto(
    val title: String,
    val price: BigDecimal,
    val publicationStatus: PublicationStatus,
    val authors: List<String>,
    val updatedBy: String = "system"
) {
    companion object {
        fun from(title: String, request: UpdateBookRequest): UpdateBookDto {
            return UpdateBookDto(
                title = title,
                price = request.price,
                publicationStatus = request.publicationStatus,
                authors = request.authors
            )
        }
    }
}
```

## バリデーションアノテーション

### 標準バリデーション
- `@NotNull`: null値不可
- `@NotBlank`: 空文字、空白不可
- `@NotEmpty`: 空のコレクション不可
- `@Size`: 文字数・要素数制限
- `@DecimalMin`: 数値の最小値
- `@Past`: 過去の日付のみ許可

### カスタムバリデーション
```kotlin
/**
 * 出版状況変更の妥当性チェック
 */
@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.RUNTIME)
@Constraint(validatedBy = [PublicationStatusTransitionValidator::class])
annotation class ValidPublicationStatusTransition(
    val message: String = "出版状況の変更が不正です",
    val groups: Array<KClass<*>> = [],
    val payload: Array<KClass<out Payload>> = []
)

/**
 * PublicationStatusTransitionValidator実装
 */
class PublicationStatusTransitionValidator : ConstraintValidator<ValidPublicationStatusTransition, UpdateBookRequest> {
    override fun isValid(request: UpdateBookRequest?, context: ConstraintValidatorContext?): Boolean {
        // 実装詳細は後述
        return true // 仮実装
    }
}
```

## マッピング戦略

### Entity ↔ DTO変換
```kotlin
/**
 * Entity/DTO変換ユーティリティ
 */
object EntityDtoMapper {
    
    /**
     * AuthorEntity → AuthorResponse
     */
    fun toAuthorResponse(author: Author): AuthorResponse {
        return AuthorResponse.from(author)
    }
    
    /**
     * BookEntity + Authors → BookResponse
     */
    fun toBookResponse(book: Book, authors: List<String>): BookResponse {
        return BookResponse.from(book, authors)
    }
    
    /**
     * CreateAuthorRequest → CreateAuthorDto
     */
    fun toCreateAuthorDto(request: CreateAuthorRequest): CreateAuthorDto {
        return CreateAuthorDto.from(request)
    }
    
    /**
     * CreateBookRequest → CreateBookDto
     */
    fun toCreateBookDto(request: CreateBookRequest): CreateBookDto {
        return CreateBookDto.from(request)
    }
}
```

## エラーハンドリング用DTO

### バリデーションエラー
```kotlin
/**
 * バリデーションエラー詳細
 */
data class ValidationErrorDto(
    val field: String,
    val message: String,
    val rejectedValue: Any? = null,
    val code: String? = null
)

/**
 * バリデーションエラーレスポンス
 */
data class ValidationErrorResponse(
    val success: Boolean = false,
    val message: String = "入力値に問題があります",
    val errors: List<ValidationErrorDto>,
    val timestamp: String = LocalDateTime.now().toString()
)
```

## 使用例

### Controller実装例
```kotlin
@RestController
@RequestMapping("/api/authors")
class AuthorController(private val authorService: AuthorService) {

    @PostMapping
    fun createAuthor(@Valid @RequestBody request: CreateAuthorRequest): ResponseEntity<ApiResponse<AuthorResponse>> {
        val dto = CreateAuthorDto.from(request)
        val author = authorService.createAuthor(dto)
        val response = AuthorResponse.from(author)
        
        return ResponseEntity.status(HttpStatus.CREATED)
            .body(ApiResponse(data = response, message = "著者を登録しました"))
    }
}
```

## テスト用DTO

### テストデータファクトリー
```kotlin
/**
 * テスト用DTOファクトリー
 */
object TestDtoFactory {
    
    fun createAuthorRequest(
        name: String = "テスト著者",
        birthDate: LocalDate = LocalDate.of(1980, 1, 1)
    ): CreateAuthorRequest {
        return CreateAuthorRequest(name, birthDate)
    }
    
    fun createBookRequest(
        title: String = "テスト書籍",
        price: BigDecimal = BigDecimal("1000"),
        publicationStatus: PublicationStatus = PublicationStatus.UNPUBLISHED,
        authors: List<String> = listOf("テスト著者")
    ): CreateBookRequest {
        return CreateBookRequest(title, price, publicationStatus, authors)
    }
}
```

## 注意事項

### パフォーマンス考慮
- 大量データの場合はページネーション対応
- 不要なフィールドの除外
- 循環参照の防止

### セキュリティ考慮
- 機密情報をレスポンスに含めない
- 入力値のサニタイゼーション
- 適切なバリデーションの実装

### 保守性考慮
- DTOの役割を明確にする
- 変換ロジックの複雑化を避ける
- 適切なドキュメント化